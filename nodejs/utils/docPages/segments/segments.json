[{"type":"text","sequence":0,"content":"Node.js is an open-source server side runtime environment built on Chrome's V8 JavaScript engine.","id":1,"pageId":1},{"type":"text","sequence":1,"content":"To access the node REPL, simply type \"node\" in your console.","id":2,"pageId":1},{"type":"text","sequence":2,"content":"Node Package Manager (NPM) is a command line tool that installs, updates or uninstalls Node.js packages in your application.\n\nKind of like Maven for Java\n\nTo get started we can install packages using:","id":3,"pageId":1},{"type":"code","sequence":3,"content":"npm install <package name>    //local\nnpm install -g <package name> //global","id":4,"pageId":1},{"type":"text","sequence":4,"content":"The same can be done with update and uninstall:","id":5,"pageId":1},{"type":"code","sequence":5,"content":"npm update <package name> \nnpm uninstall <package name> ","id":6,"pageId":1},{"type":"text","sequence":6,"content":"Some of these commands can also be used with the shorthand versions","id":7,"pageId":1},{"type":"code","sequence":7,"content":"npm i <package name> //install\nnpm u <package name> //uninstall\n ","id":8,"pageId":1},{"type":"text","sequence":8,"content":"And of course you can run your programs using:","id":9,"pageId":1},{"type":"code","sequence":9,"content":"node server.js","id":10,"pageId":1},{"type":"text","sequence":10,"content":"A tip is to use Nodemon to restart the program, when a file has been changed. \n\nTo install nodemon, use the following: ","id":11,"pageId":1},{"type":"code","sequence":11,"content":"npm i nodemon","id":12,"pageId":1},{"type":"text","sequence":12,"content":"And to use it, use:","id":13,"pageId":1},{"type":"code","sequence":13,"content":"npx nodemon server.js","id":14,"pageId":1},{"type":"text","sequence":14,"content":"To change what files nodemon checks, for updates in, add a nodemon.json file in the root. And add:","id":15,"pageId":1},{"type":"code","sequence":15,"content":"{\n    \"ext\": \"js,json,html,css\" // or other file formats\n}","id":16,"pageId":1},{"type":"text","sequence":0,"content":"Java supports a number of different data\ntypes, as follows:\n 1. String\n 2. Number\n 3. Bigint\n 4. Boolean\n 5. Undefined\n 6. Null\n 7. Symbol\n 8. Object\n\nBut under Object there are also some more \"types\", like:\n 1. An object\n 2. An array\n 3. A date ","id":17,"pageId":2},{"type":"text","sequence":1,"content":"But is node.js we don't have all of the data types, but these exists:\n1. String\n2. Number\n3. Boolean\n4. Undefined\n5. Null\n6. RegExp\n\nAnd Objects contains everything else.","id":18,"pageId":2},{"type":"text","sequence":2,"content":"Somthing interesting in JS, is that more than just the boolean can evaluvated as true or false. \nIn fact a truthy value is a value that is considered true when encountered in a Boolean context. \nAll values are truthy unless they are defined as falsy. \nThat is, all values are truthy except false, 0, -0, 0n, \"\", null, undefined, and NaN.\n\nMeaning all of these are truthy: ","id":19,"pageId":2},{"type":"code","sequence":3,"content":"if (true)\nif ({})\nif ([])\nif (42)\nif (\"0\")\nif (\"false\")\nif (new Date())\nif (-42)\nif (12n)\nif (3.14)\nif (-3.14)\nif (Infinity)\nif (-Infinity)","id":20,"pageId":2},{"type":"text","sequence":4,"content":"And these would be falsy:","id":21,"pageId":2},{"type":"code","sequence":5,"content":"if (false)\nif (null) \nif (undefined)\nif (0)\nif (-0)\nif (0n)\nif (NaN)\nif (\"\")","id":22,"pageId":2},{"type":"text","sequence":6,"content":"And when we are trying to copy objects, and or overwrite part and add parts to them in the process, we can use the spread operator like this:","id":23,"pageId":2},{"type":"code","sequence":7,"content":"{ ...Object, newKey: \"and value\"}","id":24,"pageId":2},{"type":"text","sequence":0,"content":"Git is a version control system. Which helps you keep track of code changes.\nAnd more importantly, Git is used to collaborate on code, with others.","id":25,"pageId":3},{"type":"text","sequence":1,"content":"To clone a repository, go to the desired directory, to put it in.\nThen use this command: ","id":26,"pageId":3},{"type":"code","sequence":2,"content":"git clone <url to repo>","id":27,"pageId":3},{"type":"text","sequence":3,"content":"You can see the status of you repo, by using:","id":28,"pageId":3},{"type":"code","sequence":4,"content":"git status","id":29,"pageId":3},{"type":"text","sequence":5,"content":"To add files or changes in files, to the staging, use:","id":30,"pageId":3},{"type":"code","sequence":6,"content":"git add <file>\n\n// or to add all files \ngit add -A","id":31,"pageId":3},{"type":"text","sequence":7,"content":"When you are ready to commit to the changes made, we can do that by using \"git commit\".\nBUT we should always remember to add a message, by: ","id":32,"pageId":3},{"type":"code","sequence":8,"content":"git commit -m \"the message\"","id":33,"pageId":3},{"type":"text","sequence":9,"content":"And now, you can push to the upstream repo, by using:","id":34,"pageId":3},{"type":"code","sequence":10,"content":"git push","id":35,"pageId":3},{"type":"text","sequence":11,"content":"And to check and download the changes from the upstream server, we can use the following commands.","id":36,"pageId":3},{"type":"code","sequence":12,"content":"git pull \n\n// or you can use \ngit fetch \ngit merge","id":37,"pageId":3},{"type":"text","sequence":13,"content":"Git uses branches to help separate changes made concurrently.\n\nTo make a new branch, use:","id":38,"pageId":3},{"type":"code","sequence":14,"content":"git branch new-branch-name","id":39,"pageId":3},{"type":"text","sequence":15,"content":"And to change to a branch, use:","id":40,"pageId":3},{"type":"code","sequence":16,"content":"git checkout branch-name","id":41,"pageId":3},{"type":"text","sequence":0,"content":"REST is an acronym for REpresentational State Transfer. ","id":42,"pageId":4},{"type":"text","sequence":1,"content":"Uniform Interface\n\nThis concept dictates that all API queries for the same resource, regardless of their origin, should be identical, that is, a consistent language.\n\nAnother principle states that messages should be self-descriptive. That is a get request should get something, and not delete, or something other than get. \n\ne.i. this means that an enpoint for eggs, could look like this:","id":43,"pageId":4},{"type":"code","sequence":2,"content":"GET    /eggs   // to get all eggs\nGET    /eggs/1 // to get the egg with id 1\nPOST   /eggs   // to add a new egg to the collection\nPUT    /eggs/1 // to put the new info into the egg\nPATCH  /eggs/1 // to patch the info in the egg with the given data\nDELETE /eggs/1 // to delete egg with id 1","id":44,"pageId":4},{"type":"text","sequence":3,"content":"Client-Server Separation\n\nThis means that the server code and client code is independent from each other. This helps to mitigate errors on the client side affecting the server and vice versa.","id":45,"pageId":4},{"type":"text","sequence":4,"content":"Stateless Communication Between Clients and Servers \n\nREST-based systems are stateless, meaning that the client state remains unknown to the server and vice versa. This constraint allows the server and the client to understand any sent message, even if they haven’t seen the preceding ones. \n\nNote that each request should include all the information required to complete it. Client applications have to save the session state since server apps shouldn’t store any data linked with a client request.","id":46,"pageId":4},{"type":"text","sequence":0,"content":"\"Express is a fast, unopinionated minimalist web framework for Node.js\" - official web site: Expressjs.com ","id":47,"pageId":5},{"type":"text","sequence":1,"content":"Express.js is a web application framework for Node.js. It provides various features that make web application development fast and easy","id":48,"pageId":5},{"type":"text","sequence":2,"content":"To install express we can use node:","id":49,"pageId":5},{"type":"code","sequence":3,"content":"npm install express","id":50,"pageId":5},{"type":"text","sequence":4,"content":"Then we can get a basic setup working, by first importing, then instantiating, and finally starting the server by calling listen.\nLike this: ","id":51,"pageId":5},{"type":"code","sequence":5,"content":"import express from \"express\";\nconst app = express();\n\n// with the endpoints inbetween\n\napp.listen(PORT, () => {\n    console.log(`Server is running on port ${PORT}`);\n});","id":52,"pageId":5},{"type":"text","sequence":6,"content":"For defining endpoints, we should use the methods in app, for GET, POST, PUT and DELETE.\nLike this:","id":53,"pageId":5},{"type":"code","sequence":7,"content":"app.get('/', (req, res) => {\n    res.send('<html><body><h1>Hello World</h1></body></html>');\n});\n\napp.post('/submit-data', (req, res) => {\n    res.send('POST Request');\n});\n\napp.put('/update-data', (req, res) => {\n    res.send('PUT Request');\n});\n\napp.delete('/delete-data', (req, res) => {\n    res.send('DELETE Request');\n});","id":54,"pageId":5},{"type":"text","sequence":8,"content":"But how do you get the request params or data out of the body of a request?\n\nWell, we can get them from the req object we added to the anon function above.\nLike this:","id":55,"pageId":5},{"type":"code","sequence":9,"content":"app.post(\"/api/pages\", (req, res) => {\n    const title = docPages.create(req.body);\n    res.send({title: title});\n}); \n\n// or \napp.delete(\"/api/pages/:id\", (req, res) => {\n    docPages.deletePage(Number(req.params.id));\n    res.sendStatus(200);\n}); ","id":56,"pageId":5},{"type":"text","sequence":10,"content":"And to send data back to the user.\nWe can do somthing like this:","id":57,"pageId":5},{"type":"code","sequence":11,"content":"// For when you have the data ready\nres.send('<html><body><h1>Hello World</h1></body></html>');\n\n// For when you want to send a status\nres.sendStatus(200);\n\n// For when you want to send a file on your system\nres.sendFile(\"Path to file\");","id":58,"pageId":5},{"type":"text","sequence":12,"content":"But instead of defining an endpoint for each resource we have, we can set a folder for express to serve from. \nThis is called the static folder in express, and is set as follows:","id":59,"pageId":5},{"type":"code","sequence":13,"content":"app.use(express.static(\"public\"));","id":60,"pageId":5},{"type":"text","sequence":14,"content":"But how do we tell express which type of data to send and expect in return.\nWell for json, we can do this:","id":61,"pageId":5},{"type":"code","sequence":15,"content":"app.use(express.json());","id":62,"pageId":5},{"type":"text","sequence":0,"content":"Streams in javascripts, is a way to handle data in collections like arrays. \nAnd do something with them, in an easier way, and the items aren’t retrieved until they’re required, making them more memory efficient.","id":63,"pageId":6},{"type":"text","sequence":1,"content":"To start with, lets take the .forEach(), which simply does something for each element the collection.","id":64,"pageId":6},{"type":"code","sequence":2,"content":"array.forEach((element) => {\n    // do something\n});","id":65,"pageId":6},{"type":"text","sequence":3,"content":"Map, takes each element in the array and converts it to a different type","id":66,"pageId":6},{"type":"code","sequence":4,"content":"array.map((number) => {\n    return String(number);\n});","id":67,"pageId":6},{"type":"text","sequence":5,"content":"Filter will output a new array, with the items that pass the conditional","id":68,"pageId":6},{"type":"code","sequence":6,"content":"array.filter((object) => {\n    return object.id === 1;\n});","id":69,"pageId":6},{"type":"text","sequence":7,"content":"Reduce will take your collection and return a single value, based upon your call back function. \nAnd whatever is returned is given as the previous value to the next element.","id":70,"pageId":6},{"type":"code","sequence":8,"content":"array.reduce((previousValue, currentValue) => {\n    return previousValue < currentValue ? previousValue : currentValue;\n})","id":71,"pageId":6},{"type":"text","sequence":0,"content":"Fetch is used to send and recieve data, through HTTP. \n\nIt is pretty simple to use, it takes the URL to hit and an optional options object. \n\nThe options contains the method, if it is different than get, headers, like the content type. \nBut more importantly the body, which can contain the data we wish to send to the server. And it can also contain other things like credentials.\n\nIn its most basic for it looks like this:","id":72,"pageId":7},{"type":"code","sequence":1,"content":"fetch(\"/api/pages\", {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\",\n        },\n        body: \"some data\",\n    });","id":73,"pageId":7},{"type":"text","sequence":2,"content":"But now how to get the data from that fetch... \n\nwell we need to handle the promise we get from the fetch. There are a few ways to do this, async/await and .then(). \n\nLike this json example:","id":74,"pageId":7},{"type":"code","sequence":3,"content":"// async/await\nasync function functionWithFetch() {\n    const response = await fetch(\"url\");\n    const result = await response.json();\n    console.log(result);\n}\n\n// fetch.then()\nfetch(\"url\")\n    .then((response) => response.json())\n    .then((result) => console.log(result));","id":75,"pageId":7},{"type":"text","sequence":0,"content":"The date Object in js is the primary way of handling dates in javascript.\n\nWhen Date is called as a function we get a string representation of the current time and date.","id":76,"pageId":8},{"type":"code","sequence":1,"content":"Date() // Tue May 12 2020 18:50:21 GMT-0500","id":77,"pageId":8},{"type":"text","sequence":2,"content":"To get a date object we can just call new on Date()\nAnd then we can we can get the string, by calling toString on it.","id":78,"pageId":8},{"type":"code","sequence":3,"content":"const date = new Date(\"2020-05-12T23:50:21.817Z\");\ndate.toString(); // Tue May 12 2020 18:50:21 GMT-0500 ","id":79,"pageId":8},{"type":"text","sequence":4,"content":"If you want to get the epoch time, you can get it by using Date.now()","id":80,"pageId":8},{"type":"code","sequence":5,"content":"Date.now(); // 628021800000","id":81,"pageId":8},{"type":"text","sequence":0,"content":"In node we have, two ways to import modules into your project.\n\nIn CommonJS we use module.exports to define what we want to export and require() to import it.\n\nLike this:","id":82,"pageId":9},{"type":"code","sequence":1,"content":"const mod1Function = () => console.log('Mod1 is alive!')\nmodule.exports = mod1Function;\n\n// and to import\nmod1Function = require('./mod1.js');","id":83,"pageId":9},{"type":"text","sequence":2,"content":"But we can also use ESmodules way of doing it, with a export object and an import statement.\n\nBut first we need to add \"type\": \"module\" to our package.json.\n\nThen we can do it like this:","id":84,"pageId":9},{"type":"code","sequence":3,"content":"const mod1Function = () => console.log('Mod1 is alive!')\nexport { mod1Function }\n\n// and to import \nimport { mod1Function } from './mod1.js'","id":85,"pageId":9},{"type":"text","sequence":0,"content":"SSR or Server Side Rendering, simply means that the web pages are populated on the backend. Instead of sending an empty page to the client, and then letting the client build the page.\n\nCSR is not neccessarily a problem, from the users viewpoint. However if we want the big search engines to find and index our pages well, this doesn't work well, as the search engine will not try to build or load the rest of the page, beyond just the HTML.\n\n\nTo do SSR we first need to load the parts of the page. Firstly we can load prebuilt parts by loading HTML pages. We can do this by using the fs module in node.js. \n\n","id":86,"pageId":10},{"type":"code","sequence":1,"content":"import fs from \"fs\";","id":87,"pageId":10},{"type":"text","sequence":2,"content":"Then we can we can load the page, and then call toString on it, to get the string instead of a byteStream, since it is easier to work with","id":88,"pageId":10},{"type":"code","sequence":3,"content":"const page = fs.readFileSync(\"./page.html\").toString();","id":89,"pageId":10},{"type":"text","sequence":4,"content":"After this we need something in the HTML to replace with the content we want. Usually this is done with some kind of prefix, to easily find the right thing to replace. \nFor me I use $ as a prefix, and all caps as it is unusual in regular text.\n\nAnd we can do it like this: ","id":90,"pageId":10},{"type":"code","sequence":5,"content":"page = page.replace('$CONTENT', content);","id":91,"pageId":10},{"type":"text","sequence":6,"content":"And with these simple steps, and some more sophisticated mechanisms, very complex pages can be built dynamicly","id":92,"pageId":10}]